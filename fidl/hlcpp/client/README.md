# Implement a FIDL async client
> This tutorial implements a client for a FIDL protocl and runs it against the server created in the
[previous tutorial](https://dongchanyear.medium.com/implement-a-fidl-server-25a4f0cacdab). The client in 
this tutorial is asynchronous.

## What do you see when you run the client?
Run the launcher by passing it the client URL, the server URL, and the protocol that the server provides to the client:
```shell

```
The client print output in QEMU console(or using `fx log`)
```shell

```

## How to build the async client
1. Create a stub component
2. Edit GN dependencies 
3. Edit component manifest
4. Connect to the server

### 1. Create a stub conponent
Following tutorial about [create and run a component](https://dongchanyear.medium.com/implement-a-fidl-server-25a4f0cacdab)

### 2. Edit GN dependencies

### 3. Edit component manifest

### 4. Connect to the server
#### Initialize the event loop
as in the server, the code first sets up an async loop so that the client can listen for incoming responses from the 
server without blocking.
```c++
async::Loop loop(&AsyncLoopConfigAttachToCurrentThread);

loop.Run();
```

#### Initialize a proxy class
In the context of FIDL, proxy designates the code generated by the FIDL bindings that enables users to make remote
procedure calls to the server.
```c++
fuchsia::examples::EchoPtr echo_proxy;
auto context = sys::ComponentContext::Create();
context->svc()->Connect(echo_proxy.NewRequest());
```
- `fuchsia::examples::EchoPtr` is an alias for `fidl::InterfaceRequest<fuchsia::examples::Echo>` generated by the bindings 
  in [interface_ptr.h](sdk/lib/fidl/cpp/interface_ptr.h).
- The code calls `EchoPtr::NewRequest()`, which creates a channel, binds the class to one endpoint of a newly created
channel and return the other endpoint.
- The returned end of the channel is passed to `sys::ServiceDirectory::Connect()`.  

#### Set an error handler
Finally, the code sets an error handler for the proxy:
```c++
echo_proxy.set_error_handler([&loop](zx_status_t status) {
  printf("Error reading incoming message: %d\n", status);
  loop.Quit();
});
```

#### Send requests to the server
The code make two request to the server:
- An `EchoString` request
- A `SendString` request
```c++
echo_proxy->SendString("hi");
echo_proxy->EchoString("hello", [&](std::string response) {
  printf("Got response %s\n", response.c_str());
  if (++num_responses == 2) {
    loop.Quit();
  }
});

```

#### Set an event handler
The code set a handler for any incoming `OnString` events:
```c++
echo_proxy.events().OnString = [&](std::string response){
  printf("Got event %s\n", response.c_str());
  if (++num_responses == 2){
    loop.Quit();
  }
};
```

#### Terminate the event loop
Terminate the event loop when `num_responses` is greater than or equal to `2`.
